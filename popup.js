let validateBtn = document.getElementById('validateBtn');
let collectBtn = document.getElementById('collectBtn');
let errorsField = document.getElementById('warnings');
let warningField = document.getElementById('errors');
let counter = 0;
let errorCounter =0;
let warningCounter =0;
let domObject = null;

function getGitCodeRaw(githubContent){
  console.log(githubContent)
  var tables = githubContent.getElementsByTagName("table");//only 1 table, don't worry about it
  var myTable = tables[0];
  var tuples = myTable.getElementsByTagName("td"); //all tuples in the table

  var resultString = "";
  var tupleCheckClass = "blob-code-inner"; //class only the right tuples would have

  for (let i = 0; i < tuples.length; i++) {   //iterate for every tuple
      if(tuples[i].classList.contains(tupleCheckClass)){  //only tuples with the check class
          resultString += " "+ tuples[i].innerText;   //add to string, might want to handle them differently here
      }
  }

  return resultString;   
}

function modifyDOM(){

  var output = document.body;
  
  var result = getGitCodeRaw(output);
  console.log(result);
  return result;

}
function getDom() {
  chrome.tabs.executeScript({
      code: '(' + modifyDOM + ')();' //argument here is a string but function.toString() returns function's code
  }, (results) => {
      console.log(results);
      chrome.storage.sync.set({ [ "dom" + counter ] : results }, function(){
        collectBtn.style.backgroundColor = "#00ff00";
        
        getStorage("dom"+counter);

      });
       
      //Here we have just the innerHTML and not DOM structure
      
  });
}


function getStorage(storageName){
  chrome.storage.sync.get(storageName, function (data) {
    domObject = data[storageName];
    
  });
}
collectBtn.onclick = function(){
  getDom();
  
}
validateBtn.onclick = async function(element){
    // here code for the vulnerabilities
    collectBtn.style.backgroundColor = "#ffffff";
  testContract(domObject)

};

function testContract(domObject){
  // crypto magic.exe
  if(domObject != null){
    checkForUintOverOrUnderflow(domObject);
    wrongUseOfTimeStamp(domObject);

    if(warningCounter >=0 || errorCounter >=0){
      validateBtn.style.backgroundColor = "#ff0000";
      warningField.innerText ="Warings: "+ warningCounter;
      errorsField.innerText = "Errors: "+ errorCounter;
      warningCounter = 0;
      errorCounter = 0;
    }

  }else{
    console.log("domObjc is null");
  }
}
function checkForUintOverOrUnderflow(domObjc){
  console.log(domObjc);
  // check if the better math lib from openZeppelin imported
  if(domObjc.includes("import \"@openzeppelin/contracts/math/Math.sol\"") ||
     domObjc.includes("import \"openzeppelin/contracts/math/Math.sol\"")){
    // we trust, that they use the new operations of the lib
    return;
  }else if(!(domObject.includes("uint8") && domObject.includes("uint"))){
    return;
  }else if(domObject.includes("uint8")){
    // check if the uint8 in a 
    //operation and add as error or warning, that the int can be exploited
    let uint8Index = domObject.indexOf("uint8");
    
    let startIndexUint8 = uint8Index;
    let endIndexUint8 = uint8Index+6;
    // +6 is a space
    // +7 first letter new word
    // end can be a ; or space or )
    let endNewWord;

    if(domObject.includes(";",endIndexUint8)){
      endNewWord = domObject.indexOf(";", endIndexUint8 +1 );
    }else if(domObject.includes(";",endIndexUint8)){
      
      endNewWord = domObject.indexOf(")", endIndexUint8 +1 );
    }
    let uInt8Variable = domObject.substring(endIndexUint8, endNewWord);

    if(domObject.includes(uInt8Variable +" +=")||
       domObject.includes(uInt8Variable +" ="+ uInt8Variable
     +"+") || domObject.includes(uInt8Variable +" ="+ uInt8Variable
     +"-") ||domObject.includes(uInt8Variable +"-=") ){
       // user input problem => solution
      warningCounter ++;
    }
  } else if(domObject.includes("uint")){
    let uintIndex = domObject.indexOf("uint");
    let startIndexUint = uintIndex;
    let endIndexUint = uint8Index+6;

    let endNewWord;

    if(domObject.includes(";",endIndexUint)){
      console.log("in semicolon");
      endNewWord = domObject.indexOf(";", endIndexUint +1 );
    }else if(domObject.includes(";",endIndexUint)){
      console.log("in bracket");
      endNewWord = domObject.indexOf(")", endIndexUint +1 );
    }
    let uInt8Variable = domObject.substring(endIndexUint, endNewWord);

    if(domObject.includes(uInt8Variable +" +=")||
       domObject.includes(uInt8Variable +" ="+ uInt8Variable
     +"+") || domObject.includes(uInt8Variable +" ="+ uInt8Variable
     +"-") ||domObject.includes(uInt8Variable +"-=") ){
      warningCounter ++;
    }
  }else{
    return;
  }
}
// timestamps should not be used for random assumptions oder entropies
function wrongUseOfTimeStamp(domObjc){
  //check if the contract use timestamp or the alias now
  let timestampNowExist = domObjc.includes("now");
  let blockDotTimestampExists = domObjc.includes("block.timestamp");
  if(timestampNowExist ||blockDotTimestampExists){
    // check if the timestamp be used to generate randomnumbers. First hit increased the error coutner.
    if(timestampNowExist){
      let timestampNow = domObjc.substring(domObjc.indexOf("now"),
                                           domObjc.indexOf("now")+3);
      if(domObjc.includes(timestampNow +" +") ||
      domObjc.includes(timestampNow +" -") ||
      domObjc.includes(timestampNow +" *") || 
      domObjc.includes(timestampNow +" /") || 
      domObjc.includes(timestampNow +" %") ||
      domObjc.includes(timestampNow +" +=")||
      domObjc.includes(timestampNow +" -=")
      ){
       
        errorCounter++;
      }
    }else if(blockDotTimestampExists){
      let blockDotTimestamp = domObjc.substring(domObjc.indexOf("block.timestamp"),
                                                domObjc.indexOf("block.timestamp")+15);
      if(domObjc.includes(blockDotTimestamp +" +") ||
      domObjc.includes(blockDotTimestamp +" -") ||
      domObjc.includes(blockDotTimestamp +" *") || 
      domObjc.includes(blockDotTimestamp +" /") || 
      domObjc.includes(blockDotTimestamp +" %") ||
      domObjc.includes(blockDotTimestamp +" +=")||
      domObjc.includes(blockDotTimestamp +" -=")
      ){
        
        errorCounter++;
      }
    }
  }else{
    return;
  }
}





