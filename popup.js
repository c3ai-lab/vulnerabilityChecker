let validateBtn = document.getElementById('validateBtn');
let collectBtn = document.getElementById('collectBtn');
let errorsField = document.getElementById('warnings');
let warningField = document.getElementById('errors');
let counter = 0;
let errorCounter =0;
let warningCounter =0;
let domObject = null;
function modifyDOM(){

  var output = document.body.childNodes[0].innerHTML;
  return output;

}
function getDom() {
  chrome.tabs.executeScript({
      code: '(' + modifyDOM + ')();' //argument here is a string but function.toString() returns function's code
  }, (results) => {
   
      chrome.storage.sync.set({ [ "dom" + counter ] : results[0] }, function(){
        collectBtn.style.backgroundColor = "#00ff00";
        getStorage("dom"+counter);
      });
       
      //Here we have just the innerHTML and not DOM structure
      //console.log(results[0]);
  });
}

function getStorage(storageName){
  chrome.storage.sync.get(storageName, function (data) {
    domObject = data[storageName];
    
  });
}
collectBtn.onclick = function(){
  getDom();
  
}
validateBtn.onclick = async function(element){
    // here code for the vulnerabilities
    collectBtn.style.backgroundColor = "#ffffff";
  testContract(domObject)

};

function testContract(domObject){
  // crypto magic.exe
  if(domObject != null){
    console.log(domObject);
    checkForUintOverOrUnderflow(domObject);
    wrongUseOfTimeStamp(domObject);
    if(warningCounter >=0 || errorCounter >=0){
      validateBtn.style.backgroundColor = "#ff0000";
      warningField.innerText ="Warings: "+ warningCounter;
      errorsField.innerText = "Errors: "+ errorCounter;
      warningCounter = 0;
      errorCounter = 0;
    }

  }else{
    console.log("domObjc is null");
  }
}
function checkForUintOverOrUnderflow(domObjc){
  // check if the better math lib from openZeppelin imported
  var words = domObject.split(" ");
  if(domObjc.includes("import \"@openzeppelin/contracts/math/Math.sol\"") || domObjc.includes("import \"openzeppelin/contracts/math/Math.sol\"")){
    // we trust, that they use the new operations of the lib
    return;
  }else if(domObject.includes("uint8")|| domObject.includes("uint")){
    // check if the uint8 in a 
    //operation and add as error or warning, that the int can be exploited
    let uint8Index = domObject.indexOf("uint8");
    let uintIndex = domObject.indexOf("uint");
    let startIndexUint8 = uint8Index;
    let endIndexUint8 = uint8Index+6;
    // +6 is a space
    // +7 first letter new word
    // end can be a ; or space or )
    let endNewWord;
    let roundBracket = domObject.indexOf(")", endIndexUint8 +1 );
    let simicolon = domObject.indexOf(";",endIndexUint8);
    console.log(domObject[endIndexUint8]);
    if(domObject.includes(")",endIndexUint8)){
      console.log("in bracket");
      endNewWord = domObject.indexOf(")", endIndexUint8 +1 );
    }else if(domObject.includes(";",endIndexUint8)){
      console.log("in semicolon");
      endNewWord = domObject.indexOf(";", endIndexUint8 +1 );
    }
    let uInt8Variable = domObject.substring(endIndexUint8, endNewWord);
    
    console.log("uintend", endIndexUint8);
    console.log("end new word", endNewWord);
    console.log(uInt8Variable);
    if(domObject.includes(uInt8Variable +" +=")|| domObject.includes(uInt8Variable +" = var1 +")){
      warningCounter ++;
    }
    console.log(warningCounter);
  }
}
function wrongUseOfTimeStamp(domObjc){
  console.log("Next function");
}